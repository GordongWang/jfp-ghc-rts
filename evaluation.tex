\section{Execution model}

We begin our exploration of GHC's runtime system with a description
of the execution model of compiled Haskell code.

While the execution model of compiled code isn't in the domain of the
runtime system per se (it is the compiler's responsibility to generate
code that abides by the various conventions), various parts of the
execution model (e.g. heap representation, lazy evaluation) have an important
role to play in the design of components of the runtime system (e.g. the
garbage collector, concurrency).  In this section, we offer a brief
explanation of some of the most important aspects of the \emph{Spineless Tagless G-machine} (STG),
GHC's core execution model.

\subsection{(Untitled)}

What does compiled Haskell code do?  Haskell is a high-level language,
and thus compiled Haskell code bears little resemblance to the code that
was originally written.  This is in contrast to a programming language
like C, where there is a clear operational reading of the written
code.\footnote{Of course, ignoring such vagaries as under-defined
specification and optimizing compilers.}  Fortunately, GHC does have a
\emph{purely functional} intermediate language, which does have an
operational reading: this language is the \emph{Spineless Tagless
G-machine}.~\cite{PeytonJones1992}.

While there are many details to STG which an interested reader should consult
\cite{PeytonJones1992} and \cite{Marlow2006}, a brief overview the \XXX

\subsection{Heap representation}

All data on the heap is boxed, represented with a \emph{header}, which
indicates what kind of object the data is, and the \emph{payload}, which
contains the actual data for an object.  The header points to an
\emph{info table}, which provides more information about whether or not
the object is a thunk, a data constructor or a function, and describes
the layout of the payload in more detail (e.g. what fields are
pointers.) \Red{Figure}

\subsection{Spineless: Stack}

\Red{Maybe defer this later?}

\Red{Haskell code executes utilizing a \emph{eval/apply} model}



\subsection{Tagless: Lazy evaluation}

Unusually, the info table also contains \emph{code} for the object: any
object can be ``entered'' (by jumping to the code in the infotable) in
order to evaluate it.  This is perhaps the most important design
decision in STG: it prescribes a uniform data representation for both
fully evaluated data values (constructors and functions) and unevaluated
thunks---referred to collectively as \emph{closures}.  In the original
design of the STG, all code wanting to access a field in a data
structure first entered the closure and upon return would receive the
values of the data structure (a \emph{vectored return}).  The lack of
any check whether or not a thunk was evaluated or not (an obvious
alternative implementation strategy) is behind the ``tagless`` in STG's
name.

\SM{We don't do vectored returns, since GHC 4.0. Also
  return-in-registers, which you might also find menioned in the
  original STG paper, was removed in favour of unboxed tuples.}

\SM{Tagless is a bit debatable these days.  We have tags in pointers
  (pointer tagging).  Also the code pointer for a function closure is
  the entry code for the function (not the ``eval'' code).}

The fact that objects are always entered is an extremely helpful layer
of indirection which is used for a variety of purposes by the runtime.
For example, when a thunk finishes evaluation, we need to write back the
true value to the old memory location so the computation is not
repeated.  If the new value is larger than the thunk, it must be placed
in new heap memory and the old thunk replaced with an \emph{indirection}
pointer pointing to the new value.  An indirection object, then, simply
jumps to the code of the indirectee!  This flexibility is useful for a
number of other exceptional conditions, especially in the case of
concurrency.

Unfortunately, code compiled this way performs a lot of indirect jumps,
and modern branch prediction units on processors typically perform very
poorly under such control flow.  This might suggest that this data
representation is quite expensive and of little interest to implementors
of non-lazy languages.  Fortunately, modern GHC implements a
\emph{dynamic pointer tagging} scheme~\XXX{} which, in many cases,
eliminates the need to perform an indirect jump.  This scheme works by
using the lower order bits (two bits in a 32-bit machine, and three bits
in a 64-bit machine) in order to encode whether or not pointer is
already evaluated, and if it is, what the tag of the constructor is.
When the tag bit is absent, user code will enter the closure, as before.

We think that this representation is well worth considering even for
non-lazy-by-default languages.  In the case of data types with multiple
constructors, pointer tagging enables us to support efficient case
analysis of user-defined types \emph{without a memory
dereference}---only the tag bit must be consulted.  And, to reiterate,
the added flexibility the indirect jumps will greatly aid us later in
other components of the runtime system.

\Red{Maybe explain in more detail}

\subsection{Summary}

\Red{More stuff}

The name of STG is a bit misleading: its modern implementation in GHC
would have to be described as the ``Usually-Spineless Mostly-Tagged
G-machine.''
